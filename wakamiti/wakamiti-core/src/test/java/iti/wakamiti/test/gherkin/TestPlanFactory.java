/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
package iti.wakamiti.test.gherkin;

import imconfig.Configuration;
import imconfig.ConfigurationException;
import iti.wakamiti.api.WakamitiConfiguration;
import iti.wakamiti.api.plan.NodeType;
import iti.wakamiti.api.plan.PlanNode;
import iti.wakamiti.core.Wakamiti;
import iti.wakamiti.core.gherkin.GherkinResourceType;
import org.json.JSONException;
import org.junit.ComparisonFailure;
import org.junit.Test;
import org.skyscreamer.jsonassert.JSONCompare;
import org.skyscreamer.jsonassert.JSONCompareMode;
import org.skyscreamer.jsonassert.JSONCompareResult;
import org.skyscreamer.jsonassert.comparator.DefaultComparator;
import org.skyscreamer.jsonassert.comparator.JSONComparator;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Properties;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;


/**
 * @author Luis IÃ±esta Gelabert - linesta@iti.es | luiinge@gmail.com
 */
public class TestPlanFactory {


    private void assertFilePlan(
            String filename,
            int testCases
    ) throws IOException, JSONException, ConfigurationException {
        String featureFilename = "src/test/resources/features/" + filename + ".feature";
        String resultFilename = "src/test/resources/features/" + filename + "_plan.json";
        assertFilePlan(featureFilename, resultFilename, null, testCases);
    }


    private void assertFilePlan(
            String featureFilename,
            String resultFilename,
            String tagExpression,
            int testCases
    ) throws IOException, JSONException, ConfigurationException {
        assertPlan(featureFilename, resultFilename, tagExpression, testCases, new Properties());
    }


    private void assertPathPlan(
            String featurePath,
            String resultFilename,
            String tagExpression,
            int testCases
    ) throws IOException, JSONException, ConfigurationException {
        assertPlan(featurePath, resultFilename, tagExpression, testCases, new Properties());
    }


    private void assertPlan(
            String path,
            String resultFilename,
            String tagExpression,
            int testCases,
            Properties extraProperties
    ) throws JSONException, IOException, ConfigurationException {
        Properties properties = new Properties();
        properties.put(WakamitiConfiguration.RESOURCE_TYPES, GherkinResourceType.NAME);
        properties.put(WakamitiConfiguration.RESOURCE_PATH, path);
        properties.put(WakamitiConfiguration.OUTPUT_FILE_PATH, "target/" + Path.of(resultFilename).getFileName());
        properties.putAll(extraProperties);
        if (tagExpression != null) {
            properties.put(WakamitiConfiguration.TAG_FILTER, tagExpression);
        }
        Configuration configuration = Wakamiti.defaultConfiguration()
                .appendFromProperties(properties);
        Wakamiti wakamiti = Wakamiti.instance();
        PlanNode testPlan = wakamiti.createPlanFromConfiguration(configuration);
        System.out.println(printPlan(testPlan, new StringBuilder(), 0));
        wakamiti.writeOutputFile(testPlan, configuration);

        assertThat(testPlan.numDescendants(NodeType.TEST_CASE)).isEqualTo(testCases);
        String plan = Wakamiti.planSerializer().serialize(testPlan);
        // remove autogenerated ids because they change on each execution
        plan = plan.replaceAll("\"id\" \\: \"#.*\\n", "");
        plan = plan.replaceAll("\\[#.*\\]", "\\[\\]");
        plan = plan.replaceAll("\"snapshotInstant.*\\n", "");
        String expectedResult = Wakamiti.resourceLoader().readResourceAsString(resultFilename);
        JSONComparator comparator = new DefaultComparator(JSONCompareMode.STRICT);
        JSONCompareResult comparison = JSONCompare.compareJSON(expectedResult, plan, comparator);
        if (comparison.failed()) {
            throw new ComparisonFailure(comparison.getMessage(), expectedResult, plan);
        }
    }

    @Test
    public void test1_simpleScenario() throws IOException, JSONException, ConfigurationException {
        assertFilePlan("test1_simpleScenario", 1);
    }

    @Test
    public void test2_scenarioOutline() throws IOException, JSONException, ConfigurationException {
        assertFilePlan("test2_scenarioOutline", 3);
    }

    @Test
    public void test3_background() throws IOException, JSONException, ConfigurationException {
        assertFilePlan("test3_background", 3);
    }

    @Test
    public void test4_tagExpression() throws IOException, JSONException, ConfigurationException {
        assertFilePlan(
                "src/test/resources/features/test4_tagExpression.feature",
                "src/test/resources/features/test4_tagExpression_plan.json",
                "Test4 and (B and (C or D))",
                1
        );
    }

    @Test
    public void test6_propertySubstitution() throws IOException, JSONException, ConfigurationException {
        Properties properties = new Properties();
        properties.put("number.a", "8.02");
        properties.put("number.b", "9");
        properties.put("number.c", "72.18");
        properties.put("operation", "multiplied");

        assertPlan(
                "src/test/resources/features/test6_propertySubstitution.feature",
                "src/test/resources/features/test6_propertySubstitution_plan.json",
                "",
                1,
                properties
        );
    }

    @Test
    public void testRedefining() throws IOException, JSONException, ConfigurationException {
        assertPathPlan(
                "src/test/resources/features/redefining",
                "src/test/resources/features/redefining/redefining_plan.json",
                null,
                4
        );
    }

    private StringBuilder printPlan(PlanNode node, StringBuilder string, int level) {
        StringBuilder leading = new StringBuilder();
        for (int i = 0; i < level; i++) {
            leading.append("--");
        }
        leading.append("  ").append(node.nodeType()).append("  >> ").append(node.displayName());
        string.append(
                String.format(
                        "%-100s %-40s %s\n",
                        leading,
                        node.tags().isEmpty() ? "" : node.tags().stream().sorted().map(s -> "#" + s).collect(Collectors.joining(" ")),
                        node.properties().isEmpty() ? "" : node.properties()
                )
        );
        node.children().forEach(child -> printPlan(child, string, level + 1));
        return string;
    }

}