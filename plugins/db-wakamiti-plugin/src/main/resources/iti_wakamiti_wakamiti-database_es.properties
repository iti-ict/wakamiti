#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#

# configuration steps
db.define.connection.parameters=la URL de conexión a BBDD {url:text} usando el usuario {username:text} y la contraseña {password:text}
db.define.connection.parameters.alias=la URL de conexión a BBDD {url:text} usando el usuario {username:text} y la contraseña {password:text} como {alias:text}

db.define.cleanup.document=Al finalizar, se ejecuta el siguiente script SQL:
db.define.cleanup.document.alias=Al finalizar, se ejecuta el siguiente script SQL usando la conexión {alias:text}:
db.define.cleanup.file=Al finalizar, se ejecuta el script SQL del fichero {script:file}
db.define.cleanup.file.alias=Al finalizar, se ejecuta el script SQL del fichero {script:file} usando la conexión {alias:text}

db.define.cleanup.procedure.document=Al finalizar, se ejecuta el siguiente procedimiento SQL:
db.define.cleanup.procedure.document.alias=Al finalizar, se ejecuta el siguiente procedimiento SQL usando la conexión {alias:text}:
db.define.cleanup.procedure.file=Al finalizar, se ejecuta el procedimiento SQL del fichero {proc:file}
db.define.cleanup.procedure.file.alias=Al finalizar, se ejecuta el procedimiento SQL del fichero {proc:file} usando la conexión {alias:text}

db.define.cleanup.clear.all=Al finalizar, se limpia la tabla (de BBDD) {table:word}
db.define.cleanup.clear.all.alias=Al finalizar, se limpia la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.cleanup.clear.row=Al finalizar, se elimina(n) * con {column:word} = {value:text} de la tabla (de BBDD) {table:word}
db.define.cleanup.clear.row.alias=Al finalizar, se elimina(n) * con {column:word} = {value:text} de la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.cleanup.clear.where=Al finalizar, se elimina(n) * que satisface(n) la siguiente cláusula SQL de la tabla (de BBDD) {table:word}:
db.define.cleanup.clear.where.alias=Al finalizar, se elimina(n) * que satisface(n) la siguiente cláusula SQL de la tabla (de BBDD) {table:word} usando la conexión {alias:text}:

db.define.cleanup.delete.from.data=Al finalizar, se elimina(n) (lo|el|la|los|las) siguiente(s) * de la tabla (de BBDD) {table:word}:
db.define.cleanup.delete.from.data.alias=Al finalizar, se elimina(n) (lo|el|la|los|las) siguiente(s) * de la tabla (de BBDD) {table:word} usando la conexión {alias:text}:
db.define.cleanup.delete.from.xls=Al finalizar, se elimina el contenido del fichero XLS {xls:file} de la base de datos
db.define.cleanup.delete.from.xls.alias=Al finalizar, se elimina el contenido del fichero XLS {xls:file} de la base de datos usando la conexión {alias:text}
db.define.cleanup.delete.from.csv=Al finalizar, se elimina el contenido del fichero CSV {csv:file} de la tabla (de BBDD) {table:word}
db.define.cleanup.delete.from.csv.alias=Al finalizar, se elimina el contenido del fichero CSV {csv:file} de la tabla (de BBDD) {table:word} usando la conexión {alias:text}

db.define.cleanup.insert.from.data=Al finalizar, se inserta(n) (lo|el|la|los|las) siguiente(s) * en la tabla (de BBDD) {table:word}:
db.define.cleanup.insert.from.data.alias=Al finalizar, se inserta(n) (lo|el|la|los|las) siguiente(s) * en la tabla (de BBDD) {table:word} usando la conexión {alias:text}:
db.define.cleanup.insert.from.xls=Al finalizar, se inserta el contenido del fichero XLS {xls:file} en la base de datos
db.define.cleanup.insert.from.xls.alias=Al finalizar, se inserta el contenido del fichero XLS {xls:file} en la base de datos usando la conexión {alias:text}
db.define.cleanup.insert.from.csv=Al finalizar, se inserta el contenido del fichero CSV {csv:file} en la tabla (de BBDD) {table:word}
db.define.cleanup.insert.from.csv.alias=Al finalizar, se inserta el contenido del fichero CSV {csv:file} en la tabla (de BBDD) {table:word} usando la conexión {alias:text}

db.define.assert.table.exists.row.single.id=Al finalizar, * identificad(o|a|os|as) por {id:text} existe(n) en la tabla (de BBDD) {table:word}
db.define.assert.table.exists.row.single.id.alias=Al finalizar, * identificad(o|a|os|as) por {id:text} existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.assert.table.not.exists.row.single.id=Al finalizar, * identificad(o|a|os|as) por {id:text} no existe(n) en la tabla (de BBDD) {table:word}
db.define.assert.table.not.exists.row.single.id.alias=Al finalizar, * identificad(o|a|os|as) por {id:text} no existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.assert.table.exists.row.one.column=Al finalizar, * con {column:word} = {value:text} existe(n) en la tabla (de BBDD) {table:word}
db.define.assert.table.exists.row.one.column.alias=Al finalizar, * con {column:word} = {value:text} existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.assert.table.not.exists.row.one.column=Al finalizar, * con {column:word} = {value:text} no existe(n) en la tabla (de BBDD) {table:word}
db.define.assert.table.not.exists.row.one.column.alias=Al finalizar, * con {column:word} = {value:text} no existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.assert.table.count.row.one.column=Al finalizar, el número de * con {column:word} = {value:text} en la tabla (de BBDD) {table:word} {matcher:long-assertion}
db.define.assert.table.count.row.one.column.alias=Al finalizar, el número de * con {column:word} = {value:text} en la tabla (de BBDD) {table:word} {matcher:long-assertion} usando la conexión {alias:text}
db.define.assert.table.exists.sql.where=Al finalizar, * que satisface(n) la siguiente cláusula SQL existe(n) en la tabla (de BBDD) {table:word}:
db.define.assert.table.exists.sql.where.alias=Al finalizar, * que satisface(n) la siguiente cláusula SQL existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}:
db.define.assert.table.not.exists.sql.where=Al finalizar, * que satisface(n) la siguiente cláusula SQL no existe(n) en la tabla (de BBDD) {table:word}:
db.define.assert.table.not.exists.sql.where.alias=Al finalizar, * que satisface(n) la siguiente cláusula SQL no existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}:
db.define.assert.table.count.sql.where=Al finalizar, el número de * que satisfacen la siguiente cláusula SQL en la tabla (de BBDD) {table:word} {matcher:long-assertion}:
db.define.assert.table.count.sql.where.alias=Al finalizar, el número de * que satisfacen la siguiente cláusula SQL en la tabla (de BBDD) {table:word} {matcher:long-assertion} usando la conexión {alias:text}:
db.define.assert.table.exists.data=Al finalizar, (el|los) siguiente(s) registro(s) existe(n) en la tabla (de BBDD) {table:word}:
db.define.assert.table.exists.data.alias=Al finalizar, (el|los) siguiente(s) registro(s) existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}:
db.define.assert.table.not.exists.data=Al finalizar, (el|los) siguiente(s) registro(s) no existe(n) en la tabla (de BBDD) {table:word}:
db.define.assert.table.not.exists.data.alias=Al finalizar, (el|los) siguiente(s) registro(s) no existe(n) en la tabla (de BBDD) {table:word} usando la conexión {alias:text}:
db.define.assert.table.count.data=Al finalizar, el número de * que satisfacen (lo|la) siguiente (información) en la tabla (de BBDD) {table:word} {matcher:long-assertion}:
db.define.assert.table.count.data.alias=Al finalizar, el número de * que satisfacen (lo|la) siguiente (información) en la tabla (de BBDD) {table:word} {matcher:long-assertion} usando la conexión {alias:text}:
db.define.assert.table.exists.xls=Al finalizar, el contenido del fichero XLS {xls:file} existe en la base de datos
db.define.assert.table.exists.xls.alias=Al finalizar, el contenido del fichero XLS {xls:file} existe en la base de datos usando la conexión {alias:text}
db.define.assert.table.not.exists.xls=Al finalizar, el contenido del fichero XLS {xls:file} no existe en la base de datos
db.define.assert.table.not.exists.xls.alias=Al finalizar, el contenido del fichero XLS {xls:file} no existe en la base de datos usando la conexión {alias:text}
db.define.assert.table.exists.csv=Al finalizar, el contenido del fichero CSV {csv:file} existe en la tabla (de BBDD) {table:word}
db.define.assert.table.exists.csv.alias=Al finalizar, el contenido del fichero CSV {csv:file} existe en la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.assert.table.not.exists.csv=Al finalizar, el contenido del fichero CSV {csv:file} no existe en la tabla (de BBDD) {table:word}
db.define.assert.table.not.exists.csv.alias=Al finalizar, el contenido del fichero CSV {csv:file} no existe en la tabla (de BBDD) {table:word} usando la conexión {alias:text}
db.define.assert.table.not.empty=Al finalizar, la tabla (de BBDD) {table:word} no está vacía
db.define.assert.table.not.empty.alias=Al finalizar, la tabla (de BBDD) {table:word} no está vacía usando la conexión {alias:text}
db.define.assert.table.empty=Al finalizar, la tabla (de BBDD) {table:word} está vacía
db.define.assert.table.empty.alias=Al finalizar, la tabla (de BBDD) {table:word} está vacía usando la conexión {alias:text}



db.select.data=(se recupera) (el|los) valor(es) de la siguiente consulta SQL:
db.select.file=(se recupera) (el|los) valor(es) de la consulta SQL del fichero {sql:file}

db.switch.connection=(que) se usa la conexión {alias:text}
db.switch.connection.default=(que) se usa la conexión por defecto

# script execution steps
db.action.script.document=(que) se (ha) ejecuta(do) el siguiente script SQL:
db.action.script.file=(que) se (ha) ejecuta(do) el script SQL del fichero {script:file}
db.action.procedure.document=(que) se (ha) ejecuta(do) el siguiente procedimiento SQL:
db.action.procedure.file=(que) se (ha) ejecuta(do) el procedimiento SQL del fichero {proc:file}

# insert data execution steps
db.action.insert.from.data=(que) se (ha) inserta(n|do) (lo|el|la|los|las) siguiente(s) * en la tabla (de BBDD) {table:word}:
db.action.insert.from.xls=(que) se (ha) inserta(do) el contenido del fichero XLS {xls:file} en la base de datos
db.action.insert.from.csv=(que) se (ha) inserta(do) el contenido del fichero CSV {csv:file} en la tabla (de BBDD) {table:word}

# delete data execution steps
db.action.delete.from.data=(que) se (ha) elimina(do) (lo|el|la|los|las) siguiente(s) * de la tabla (de BBDD) {table:word}:
db.action.delete.from.xls=(que) se (ha) elimina(do) el contenido del fichero XLS {xls:file} de la base de datos
db.action.delete.from.csv=(que) se (ha) elimina(do) el contenido del fichero CSV {csv:file} de la tabla (de BBDD) {table:word}
db.action.clear.table.all=(que) se (ha) limpia(do) la tabla (de BBDD) {table:word}
db.action.clear.table.row=(que) se (ha) elimina(n|do) * con {column:word} = {value:text} de la tabla (de BBDD) {table:word}
db.action.clear.table.where=(que) se (ha) elimina(n|do) * que satisfacen la siguiente cláusula SQL en la tabla (de BBDD) {table:word}:

# data presence assertion steps
db.assert.table.exists.row.single.id=(!Al finalizar) identificad(o|a|os|as) por {id:text} existe(n) en la tabla (de BBDD) {table:word}
db.assert.table.exists.row.single.id.async=(!Al finalizar) identificad(o|a|os|as) por {id:text} existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}
db.assert.table.not.exists.row.single.id=(!Al finalizar) identificad(o|a|os|as) por {id:text} no existe(n) en la tabla (de BBDD) {table:word}
db.assert.table.not.exists.row.single.id.async=(!Al finalizar) identificad(o|a|os|as) por {id:text} no existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}
db.assert.table.exists.row.one.column=(!Al finalizar) con {column:word} = {value:text} existe(n) en la tabla (de BBDD) {table:word}
db.assert.table.exists.row.one.column.async=(!Al finalizar) con {column:word} = {value:text} existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}
db.assert.table.not.exists.row.one.column=(!Al finalizar) con {column:word} = {value:text} no existe(n) en la tabla (de BBDD) {table:word}
db.assert.table.not.exists.row.one.column.async=(!Al finalizar) con {column:word} = {value:text} no existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}
db.assert.table.count.row.one.column=(que) el número de * con {column:word} = {value:text} en la tabla (de BBDD) {table:word} {matcher:long-assertion}
db.assert.table.count.row.one.column.async=(que) el número de * con {column:word} = {value:text} en la tabla (de BBDD) {table:word} {matcher:long-assertion} en {duration:duration}
db.assert.table.exists.sql.where=(!Al finalizar) que satisface(n) la siguiente cláusula SQL existe(n) en la tabla (de BBDD) {table:word}:
db.assert.table.exists.sql.where.async=(!Al finalizar) que satisface(n) la siguiente cláusula SQL existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}:
db.assert.table.not.exists.sql.where=(!Al finalizar) que satisface(n) la siguiente cláusula SQL no existe(n) en la tabla (de BBDD) {table:word}:
db.assert.table.not.exists.sql.where.async=(!Al finalizar) que satisface(n) la siguiente cláusula SQL no existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}:
db.assert.table.count.sql.where=(que) el número de * que satisfacen la siguiente cláusula SQL en la tabla (de BBDD) {table:word} {matcher:long-assertion}:
db.assert.table.count.sql.where.async=(que) el número de * que satisfacen la siguiente cláusula SQL en la tabla (de BBDD) {table:word} {matcher:long-assertion} en {duration:duration}:
db.assert.table.exists.data=(que) (el|los) siguiente(s) registro(s) existe(n) en la tabla (de BBDD) {table:word}:
db.assert.table.exists.data.async=(que) (el|los) siguiente(s) registro(s) existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}:
db.assert.table.not.exists.data=(que) (el|los) siguiente(s) registro(s) no existe(n) en la tabla (de BBDD) {table:word}:
db.assert.table.not.exists.data.async=(que) (el|los) siguiente(s) registro(s) no existe(n) en la tabla (de BBDD) {table:word} en {duration:duration}:
db.assert.table.count.data=(que) el número de * que satisfacen (lo|la) siguiente (información) en la tabla (de BBDD) {table:word} {matcher:long-assertion}:
db.assert.table.count.data.async=(que) el número de * que satisfacen (lo|la) siguiente (información) en la tabla (de BBDD) {table:word} {matcher:long-assertion} en {duration:duration}:
db.assert.table.exists.xls=(que) el contenido del fichero XLS {xls:file} existe en la base de datos
db.assert.table.exists.xls.async=(que) el contenido del fichero XLS {xls:file} existe en la base de datos en {duration:duration}
db.assert.table.not.exists.xls=(que) el contenido del fichero XLS {xls:file} no existe en la base de datos
db.assert.table.not.exists.xls.async=(que) el contenido del fichero XLS {xls:file} no existe en la base de datos en {duration:duration}
db.assert.table.exists.csv=(que) el contenido del fichero CSV {csv:file} existe en la tabla (de BBDD) {table:word}
db.assert.table.exists.csv.async=(que) el contenido del fichero CSV {csv:file} existe en la tabla (de BBDD) {table:word} en {duration:duration}
db.assert.table.not.exists.csv=(que) el contenido del fichero CSV {csv:file} no existe en la tabla (de BBDD) {table:word}
db.assert.table.not.exists.csv.async=(que) el contenido del fichero CSV {csv:file} no existe en la tabla (de BBDD) {table:word} en {duration:duration}
db.assert.table.not.empty=(que) la tabla (de BBDD) {table:word} no está vacía
db.assert.table.not.empty.async=(que) la tabla (de BBDD) {table:word} no está vacía en {duration:duration}
db.assert.table.empty=(que) la tabla (de BBDD) {table:word} está vacía
db.assert.table.empty.async=(que) la tabla (de BBDD) {table:word} está vacía en {duration:duration}
