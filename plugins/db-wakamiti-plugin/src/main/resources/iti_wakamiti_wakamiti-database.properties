#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#

# configuration steps
db.define.connection.parameters=the database connection URL {url:text} using the user {username:text} and the password {password:text}
db.define.connection.parameters.alias=the database connection URL {url:text} using the user {username:text} and the password {password:text} as {alias:text}

db.define.cleanup.document=At finish, the following SQL script is executed:
db.define.cleanup.document.alias=At finish, the following SQL script is executed using {alias:text} connection:
db.define.cleanup.file=At finish, the SQL script file {script:file} is executed
db.define.cleanup.file.alias=At finish, the SQL script file {script:file} is executed using {alias:text} connection

db.define.cleanup.clear.all=At finish, the (database) table {table:word} is cleared
db.define.cleanup.clear.all.alias=At finish, the (database) table {table:word} is cleared using {alias:text} connection
db.define.cleanup.clear.row=At finish, * having {column:word} = {value:text} (is|are) deleted from the (database) table {table:word}
db.define.cleanup.clear.row.alias=At finish, * having {column:word} = {value:text} (is|are) deleted from the (database) table {table:word} using {alias:text} connection
db.define.cleanup.clear.where=At finish, * satisfying the following SQL clause (is|are) deleted from the (database) table {table:word}:
db.define.cleanup.clear.where.alias=At finish, * satisfying the following SQL clause (is|are) deleted from the (database) table {table:word} using {alias:text} connection:

db.define.cleanup.delete.from.data=At finish, the following * (is|are) deleted from the (database) table {table:word}:
db.define.cleanup.delete.from.data.alias=At finish, the following * (is|are) deleted from the (database) table {table:word} using {alias:text} connection:
db.define.cleanup.delete.from.xls=At finish, the content of the XLS file {xls:file} (is) deleted from the database
db.define.cleanup.delete.from.xls.alias=At finish, the content of the XLS file {xls:file} (is) deleted from the database using {alias:text} connection
db.define.cleanup.delete.from.csv=At finish, the content of the CSV file {csv:file} (is) deleted from the (database) table {table:word}
db.define.cleanup.delete.from.csv.alias=At finish, the content of the CSV file {csv:file} (is) deleted from the (database) table {table:word} using {alias:text} connection

db.define.cleanup.insert.from.data=At finish, the following * (is|are) inserted into the (database) table {table:word}:
db.define.cleanup.insert.from.data.alias=At finish, the following * (is|are) inserted into the (database) table {table:word} using {alias:text} connection:
db.define.cleanup.insert.from.xls=At finish, the content of the XLS file {xls:file} (is) inserted into the database
db.define.cleanup.insert.from.xls.alias=At finish, the content of the XLS file {xls:file} (is) inserted into the database using {alias:text} connection
db.define.cleanup.insert.from.csv=At finish, the content of the CSV file {csv:file} (is) inserted into the (database) table {table:word}
db.define.cleanup.insert.from.csv.alias=At finish, the content of the CSV file {csv:file} (is) inserted into the (database) table {table:word} using {alias:text} connection

db.define.assert.table.exists.row.single.id=At finish, * identified by {id:text} exist(s) in the (database) table {table:word}
db.define.assert.table.exists.row.single.id.alias=At finish, * identified by {id:text} exist(s) in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.not.exists.row.single.id=At finish, * identified by {id:text} do(es) not exist in the (database) table {table:word}
db.define.assert.table.not.exists.row.single.id.alias=At finish, * identified by {id:text} do(es) not exist in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.exists.row.one.column=At finish, * having {column:word} = {value:text} exist(s) in the (database) table {table:word}
db.define.assert.table.exists.row.one.column.alias=At finish, * having {column:word} = {value:text} exist(s) in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.not.exists.row.one.column=At finish, * having {column:word} = {value:text} do(es) not exist in the (database) table {table:word}
db.define.assert.table.not.exists.row.one.column.alias=At finish, * having {column:word} = {value:text} do(es) not exist in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.count.row.one.column=At finish, the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion}
db.define.assert.table.count.row.one.column.alias=At finish, the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion} using {alias:text} connection
db.define.assert.table.exists.sql.where=At finish, * satisfying the following SQL clause exist(s) in the (database) table {table:word}:
db.define.assert.table.exists.sql.where.alias=At finish, * satisfying the following SQL clause exist(s) in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.not.exists.sql.where=At finish, * satisfying the following SQL clause do(es) not exist in the (database) table {table:word}:
db.define.assert.table.not.exists.sql.where.alias=At finish, * satisfying the following SQL clause do(es) not exist in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.count.sql.where=At finish, the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion}:
db.define.assert.table.count.sql.where.alias=At finish, the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion} using {alias:text} connection:
db.define.assert.table.exists.data=At finish, the following record(s) exist(s) in the (database) table {table:word}:
db.define.assert.table.exists.data.alias=At finish, the following record(s) exist(s) in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.not.exists.data=At finish, the following record(s) do(es) not exist in the (database) table {table:word}:
db.define.assert.table.not.exists.data.alias=At finish, the following record(s) do(es) not exist in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.count.data=At finish, the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion}:
db.define.assert.table.count.data.alias=At finish, the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion} using {alias:text} connection:
db.define.assert.table.exists.xls=At finish, the content of the XLS file {xls:file} exists in the database
db.define.assert.table.exists.xls.alias=At finish, the content of the XLS file {xls:file} exists in the database using {alias:text} connection
db.define.assert.table.not.exists.xls=At finish, the content of the XLS file {xls:file} does not exist in the database
db.define.assert.table.not.exists.xls.alias=At finish, the content of the XLS file {xls:file} does not exist in the database using {alias:text} connection
db.define.assert.table.exists.csv=At finish, the content of the CSV file {csv:file} exists in the (database) table {table:word}
db.define.assert.table.exists.csv.alias=At finish, the content of the CSV file {csv:file} exists in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.not.exists.csv=At finish, the content of the CSV file {csv:file} does not exist in the (database) table {table:word}
db.define.assert.table.not.exists.csv.alias=At finish, the content of the CSV file {csv:file} does not exist in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.empty=At finish, the (database) table {table:word} is empty
db.define.assert.table.empty.alias=At finish, the (database) table {table:word} is empty using {alias:text} connection
db.define.assert.table.not.empty=At finish, the (database) table {table:word} is not empty
db.define.assert.table.not.empty.alias=At finish, the (database) table {table:word} is not empty using {alias:text} connection

db.select.data=the following SQL query value(s):
db.select.file=the SQL query value(s) from the file {sql:file}

db.switch.connection=the {alias:text} connection is used
db.switch.connection.default=the default connection is used

# script execution steps
db.action.script.document=the following SQL script is executed:
db.action.script.file=the SQL script file {script:file} is executed
db.action.procedure.document=the following SQL procedure is executed:
db.action.procedure.file=the SQL procedure file {proc:file} is executed

# insert data execution steps
db.action.insert.from.data=the following * (is|are) inserted into the (database) table {table:word}:
db.action.insert.from.xls=the content of the XLS file {xls:file} (is) inserted into the database
db.action.insert.from.csv=the content of the CSV file {csv:file} (is) inserted into the (database) table {table:word}

# delete data execution steps
db.action.delete.from.data=the following * (is|are) deleted from the (database) table {table:word}:
db.action.delete.from.xls=the content of the XLS file {xls:file} (is) deleted from the database
db.action.delete.from.csv=the content of the CSV file {csv:file} (is) deleted from the (database) table {table:word}
db.action.clear.table.all=the (database) table {table:word} is cleared
db.action.clear.table.row=(!At finish) having {column:word} = {value:text} (is|are) deleted from the (database) table {table:word}
db.action.clear.table.where=(!At finish) satisfying the following SQL clause (is|are) deleted from the (database) table {table:word}:

# data presence assertion steps
db.assert.table.exists.row.single.id=(!At finish) identified by {id:text} exist(s) in the (database) table {table:word}
db.assert.table.exists.row.single.id.async=(!At finish) identified by {id:text} exist(s) in the (database) table {table:word} in {time:int} second(s)
db.assert.table.not.exists.row.single.id=(!At finish) identified by {id:text} do(es) not exist in the (database) table {table:word}
db.assert.table.not.exists.row.single.id.async=(!At finish) identified by {id:text} do(es) not exist in the (database) table {table:word} in {time:int} second(s)
db.assert.table.exists.row.one.column=(!At finish) having {column:word} = {value:text} exist(s) in the (database) table {table:word}
db.assert.table.exists.row.one.column.async=(!At finish) having {column:word} = {value:text} exist(s) in the (database) table {table:word} in {time:int} second(s)
db.assert.table.not.exists.row.one.column=(!At finish) having {column:word} = {value:text} do(es) not exist in the (database) table {table:word}
db.assert.table.not.exists.row.one.column.async=(!At finish) having {column:word} = {value:text} do(es) not exist in the (database) table {table:word} in {time:int} second(s)
db.assert.table.count.row.one.column=the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion}
db.assert.table.count.row.one.column.async=the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion} in {time:int} second(s)
db.assert.table.exists.sql.where=(!At finish) satisfying the following SQL clause exist(s) in the (database) table {table:word}:
db.assert.table.exists.sql.where.async=(!At finish) satisfying the following SQL clause exist(s) in the (database) table {table:word} in {time:int} second(s):
db.assert.table.not.exists.sql.where=(!At finish) satisfying the following SQL clause do(es) not exist in the (database) table {table:word}:
db.assert.table.not.exists.sql.where.async=(!At finish) satisfying the following SQL clause do(es) not exist in the (database) table {table:word} in {time:int} second(s):
db.assert.table.count.sql.where=the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion}:
db.assert.table.count.sql.where.async=the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion} in {time:int} second(s):
db.assert.table.exists.data=the following record(s) exist(s) in the (database) table {table:word}:
db.assert.table.exists.data.async=the following record(s) exist(s) in the (database) table {table:word} in {time:int} second(s):
db.assert.table.not.exists.data=the following record(s) do(es) not exist in the (database) table {table:word}:
db.assert.table.not.exists.data.async=the following record(s) do(es) not exist in the (database) table {table:word} in {time:int} second(s):
db.assert.table.count.data=the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion}:
db.assert.table.count.data.async=the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion} in {time:int} second(s):
db.assert.table.exists.xls=the content of the XLS file {xls:file} exists in the database
db.assert.table.exists.xls.async=the content of the XLS file {xls:file} exists in the database in {time:int} second(s)
db.assert.table.not.exists.xls=the content of the XLS file {xls:file} does not exist in the database
db.assert.table.not.exists.xls.async=the content of the XLS file {xls:file} does not exist in the database in {time:int} second(s)
db.assert.table.exists.csv=the content of the CSV file {csv:file} exists in the (database) table {table:word}
db.assert.table.exists.csv.async=the content of the CSV file {csv:file} exists in the (database) table {table:word} in {time:int} second(s)
db.assert.table.not.exists.csv=the content of the CSV file {csv:file} does not exist in the (database) table {table:word}
db.assert.table.not.exists.csv.async=the content of the CSV file {csv:file} does not exist in the (database) table {table:word} in {time:int} second(s)
db.assert.table.empty=the (database) table {table:word} is empty
db.assert.table.empty.async=the (database) table {table:word} is empty in {time:int} second(s)
db.assert.table.not.empty=the (database) table {table:word} is not empty
db.assert.table.not.empty.async=the (database) table {table:word} is not empty in {time:int} second(s)
