#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#

# configuration steps
db.define.connection.parameters=the database connection URL {url:text} using the user {username:text} and the password {password:text}
db.define.connection.parameters.alias=the database connection URL {url:text} using the user {username:text} and the password {password:text} as {alias:text}

db.define.cleanup.document=On completion, the following SQL script is executed:
db.define.cleanup.document.alias=On completion, the following SQL script is executed using {alias:text} connection:
db.define.cleanup.file=On completion, the SQL script file {script:file} is executed
db.define.cleanup.file.alias=On completion, the SQL script file {script:file} is executed using {alias:text} connection

db.define.cleanup.procedure.document=On completion, the following SQL procedure is executed:
db.define.cleanup.procedure.document.alias=On completion, the following SQL procedure is executed using {alias:text} connection:
db.define.cleanup.procedure.file=On completion, the SQL procedure file {proc:file} is executed
db.define.cleanup.procedure.file.alias=On completion, the SQL procedure file {proc:file} is executed using {alias:text} connection

db.define.cleanup.clear.all=On completion, the (database) table {table:word} is cleared
db.define.cleanup.clear.all.alias=On completion, the (database) table {table:word} is cleared using {alias:text} connection
db.define.cleanup.clear.row=On completion, * having {column:word} = {value:text} (is|are) deleted from the (database) table {table:word}
db.define.cleanup.clear.row.alias=On completion, * having {column:word} = {value:text} (is|are) deleted from the (database) table {table:word} using {alias:text} connection
db.define.cleanup.clear.where=On completion, * satisfying the following SQL clause (is|are) deleted from the (database) table {table:word}:
db.define.cleanup.clear.where.alias=On completion, * satisfying the following SQL clause (is|are) deleted from the (database) table {table:word} using {alias:text} connection:

db.define.cleanup.delete.from.data=On completion, the following * (is|are) deleted from the (database) table {table:word}:
db.define.cleanup.delete.from.data.alias=On completion, the following * (is|are) deleted from the (database) table {table:word} using {alias:text} connection:
db.define.cleanup.delete.from.xls=On completion, the content of the XLS file {xls:file} (is) deleted from the database
db.define.cleanup.delete.from.xls.alias=On completion, the content of the XLS file {xls:file} (is) deleted from the database using {alias:text} connection
db.define.cleanup.delete.from.csv=On completion, the content of the CSV file {csv:file} (is) deleted from the (database) table {table:word}
db.define.cleanup.delete.from.csv.alias=On completion, the content of the CSV file {csv:file} (is) deleted from the (database) table {table:word} using {alias:text} connection

db.define.cleanup.insert.from.data=On completion, the following * (is|are) inserted into the (database) table {table:word}:
db.define.cleanup.insert.from.data.alias=On completion, the following * (is|are) inserted into the (database) table {table:word} using {alias:text} connection:
db.define.cleanup.insert.from.xls=On completion, the content of the XLS file {xls:file} (is) inserted into the database
db.define.cleanup.insert.from.xls.alias=On completion, the content of the XLS file {xls:file} (is) inserted into the database using {alias:text} connection
db.define.cleanup.insert.from.csv=On completion, the content of the CSV file {csv:file} (is) inserted into the (database) table {table:word}
db.define.cleanup.insert.from.csv.alias=On completion, the content of the CSV file {csv:file} (is) inserted into the (database) table {table:word} using {alias:text} connection

db.define.assert.table.exists.row.single.id=On completion, * identified by {id:text} exist(s) in the (database) table {table:word}
db.define.assert.table.exists.row.single.id.alias=On completion, * identified by {id:text} exist(s) in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.not.exists.row.single.id=On completion, * identified by {id:text} do(es) not exist in the (database) table {table:word}
db.define.assert.table.not.exists.row.single.id.alias=On completion, * identified by {id:text} do(es) not exist in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.exists.row.one.column=On completion, * having {column:word} = {value:text} exist(s) in the (database) table {table:word}
db.define.assert.table.exists.row.one.column.alias=On completion, * having {column:word} = {value:text} exist(s) in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.not.exists.row.one.column=On completion, * having {column:word} = {value:text} do(es) not exist in the (database) table {table:word}
db.define.assert.table.not.exists.row.one.column.alias=On completion, * having {column:word} = {value:text} do(es) not exist in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.count.row.one.column=On completion, the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion}
db.define.assert.table.count.row.one.column.alias=On completion, the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion} using {alias:text} connection
db.define.assert.table.exists.sql.where=On completion, * satisfying the following SQL clause exist(s) in the (database) table {table:word}:
db.define.assert.table.exists.sql.where.alias=On completion, * satisfying the following SQL clause exist(s) in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.not.exists.sql.where=On completion, * satisfying the following SQL clause do(es) not exist in the (database) table {table:word}:
db.define.assert.table.not.exists.sql.where.alias=On completion, * satisfying the following SQL clause do(es) not exist in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.count.sql.where=On completion, the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion}:
db.define.assert.table.count.sql.where.alias=On completion, the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion} using {alias:text} connection:
db.define.assert.table.exists.data=On completion, the following record(s) exist(s) in the (database) table {table:word}:
db.define.assert.table.exists.data.alias=On completion, the following record(s) exist(s) in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.not.exists.data=On completion, the following record(s) do(es) not exist in the (database) table {table:word}:
db.define.assert.table.not.exists.data.alias=On completion, the following record(s) do(es) not exist in the (database) table {table:word} using {alias:text} connection:
db.define.assert.table.count.data=On completion, the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion}:
db.define.assert.table.count.data.alias=On completion, the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion} using {alias:text} connection:
db.define.assert.table.exists.xls=On completion, the content of the XLS file {xls:file} exists in the database
db.define.assert.table.exists.xls.alias=On completion, the content of the XLS file {xls:file} exists in the database using {alias:text} connection
db.define.assert.table.not.exists.xls=On completion, the content of the XLS file {xls:file} does not exist in the database
db.define.assert.table.not.exists.xls.alias=On completion, the content of the XLS file {xls:file} does not exist in the database using {alias:text} connection
db.define.assert.table.exists.csv=On completion, the content of the CSV file {csv:file} exists in the (database) table {table:word}
db.define.assert.table.exists.csv.alias=On completion, the content of the CSV file {csv:file} exists in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.not.exists.csv=On completion, the content of the CSV file {csv:file} does not exist in the (database) table {table:word}
db.define.assert.table.not.exists.csv.alias=On completion, the content of the CSV file {csv:file} does not exist in the (database) table {table:word} using {alias:text} connection
db.define.assert.table.empty=On completion, the (database) table {table:word} is empty
db.define.assert.table.empty.alias=On completion, the (database) table {table:word} is empty using {alias:text} connection
db.define.assert.table.not.empty=On completion, the (database) table {table:word} is not empty
db.define.assert.table.not.empty.alias=On completion, the (database) table {table:word} is not empty using {alias:text} connection

db.select.data=the following SQL query value(s) (is|are retrieved):
db.select.file=the SQL query value(s) from the file {sql:file} (is|are retrieved)

db.switch.connection=(that) the {alias:text} connection is used
db.switch.connection.default=(that) the default connection is used

# script execution steps
db.action.script.document=(that) the following SQL script is executed:
db.action.script.file=(that) the SQL script file {script:file} is executed
db.action.procedure.document=(that) the following SQL procedure is executed:
db.action.procedure.file=(that) the SQL procedure file {proc:file} is executed

# insert data execution steps
db.action.insert.from.data=(that) the following * (is|are) inserted into the (database) table {table:word}:
db.action.insert.from.xls=(that) the content of the XLS file {xls:file} (is) inserted into the database
db.action.insert.from.csv=(that) the content of the CSV file {csv:file} (is) inserted into the (database) table {table:word}

# delete data execution steps
db.action.delete.from.data=(that) the following * (is|are) deleted from the (database) table {table:word}:
db.action.delete.from.xls=(that) the content of the XLS file {xls:file} (is) deleted from the database
db.action.delete.from.csv=(that) the content of the CSV file {csv:file} (is) deleted from the (database) table {table:word}
db.action.clear.table.all=(that) the (database) table {table:word} is cleared
db.action.clear.table.row=(!On completion) having {column:word} = {value:text} (is|are) deleted from the (database) table {table:word}
db.action.clear.table.where=(!On completion) satisfying the following SQL clause (is|are) deleted from the (database) table {table:word}:

# data presence assertion steps
db.assert.table.exists.row.single.id=(!On completion) identified by {id:text} exist(s) in the (database) table {table:word}
db.assert.table.exists.row.single.id.async=(!On completion) identified by {id:text} exist(s) in the (database) table {table:word} in {time:int} second(s)
db.assert.table.not.exists.row.single.id=(!On completion) identified by {id:text} do(es) not exist in the (database) table {table:word}
db.assert.table.not.exists.row.single.id.async=(!On completion) identified by {id:text} do(es) not exist in the (database) table {table:word} in {time:int} second(s)
db.assert.table.exists.row.one.column=(!On completion) having {column:word} = {value:text} exist(s) in the (database) table {table:word}
db.assert.table.exists.row.one.column.async=(!On completion) having {column:word} = {value:text} exist(s) in the (database) table {table:word} in {time:int} second(s)
db.assert.table.not.exists.row.one.column=(!On completion) having {column:word} = {value:text} do(es) not exist in the (database) table {table:word}
db.assert.table.not.exists.row.one.column.async=(!On completion) having {column:word} = {value:text} do(es) not exist in the (database) table {table:word} in {time:int} second(s)
db.assert.table.count.row.one.column=(that) the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion}
db.assert.table.count.row.one.column.async=(that) the number of * having {column:word} = {value:text} in the (database) table {table:word} {matcher:long-assertion} in {time:int} second(s)
db.assert.table.exists.sql.where=(!On completion) satisfying the following SQL clause exist(s) in the (database) table {table:word}:
db.assert.table.exists.sql.where.async=(!On completion) satisfying the following SQL clause exist(s) in the (database) table {table:word} in {time:int} second(s):
db.assert.table.not.exists.sql.where=(!On completion) satisfying the following SQL clause do(es) not exist in the (database) table {table:word}:
db.assert.table.not.exists.sql.where.async=(!On completion) satisfying the following SQL clause do(es) not exist in the (database) table {table:word} in {time:int} second(s):
db.assert.table.count.sql.where=(that) the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion}:
db.assert.table.count.sql.where.async=(that) the number of * satisfying the following SQL clause in the (database) table {table:word} {matcher:long-assertion} in {time:int} second(s):
db.assert.table.exists.data=(that) the following record(s) exist(s) in the (database) table {table:word}:
db.assert.table.exists.data.async=(that) the following record(s) exist(s) in the (database) table {table:word} in {time:int} second(s):
db.assert.table.not.exists.data=(that) the following record(s) do(es) not exist in the (database) table {table:word}:
db.assert.table.not.exists.data.async=(that) the following record(s) do(es) not exist in the (database) table {table:word} in {time:int} second(s):
db.assert.table.count.data=(that) the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion}:
db.assert.table.count.data.async=(that) the number of * satisfying the following (info) in the (database) table {table:word} {matcher:long-assertion} in {time:int} second(s):
db.assert.table.exists.xls=(that) the content of the XLS file {xls:file} exists in the database
db.assert.table.exists.xls.async=(that) the content of the XLS file {xls:file} exists in the database in {time:int} second(s)
db.assert.table.not.exists.xls=(that) the content of the XLS file {xls:file} does not exist in the database
db.assert.table.not.exists.xls.async=(that) the content of the XLS file {xls:file} does not exist in the database in {time:int} second(s)
db.assert.table.exists.csv=(that) the content of the CSV file {csv:file} exists in the (database) table {table:word}
db.assert.table.exists.csv.async=(that) the content of the CSV file {csv:file} exists in the (database) table {table:word} in {time:int} second(s)
db.assert.table.not.exists.csv=(that) the content of the CSV file {csv:file} does not exist in the (database) table {table:word}
db.assert.table.not.exists.csv.async=(that) the content of the CSV file {csv:file} does not exist in the (database) table {table:word} in {time:int} second(s)
db.assert.table.empty=(that) the (database) table {table:word} is empty
db.assert.table.empty.async=(that) the (database) table {table:word} is empty in {time:int} second(s)
db.assert.table.not.empty=(that) the (database) table {table:word} is not empty
db.assert.table.not.empty.async=(that) the (database) table {table:word} is not empty in {time:int} second(s)
