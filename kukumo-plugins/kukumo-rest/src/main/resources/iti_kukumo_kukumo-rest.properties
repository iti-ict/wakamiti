#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#

rest.define.contentType=the REST content type {word}
rest.define.baseURL=the base URL {url}
rest.define.service=the REST service {text}
rest.define.subject=* identified by {text}
rest.define.request.parameters=the following request parameters:
rest.define.request.parameter=the request parameter {name:text} with value {value:text}
rest.define.query.parameters=the following query parameters:
rest.define.query.parameter=the query parameter {name:text} with value {value:text}
rest.define.path.parameters=the following path parameters:
rest.define.path.parameter=the path parameter {name:text} with value {value:text}
rest.define.headers=the following headers:
rest.define.header=the header {name:text} with value {value:text}
rest.define.timeout.millis=a timeout of {int} milliseconds
rest.define.timeout.secs=a timeout of {int} seconds
rest.define.failure.http.code.assertion=any request will fail when response HTTP code {integer-assertion}
rest.define.auth.basic=the service use the basic authentication credentials {username:text}:{password:text}
rest.define.auth.bearer.password=the service use the oauth authentication credentials {username:text}:{password:text}
rest.define.auth.bearer.client=the service use the oauth authentication
rest.define.auth.bearer.token=the service use the oauth authentication token {text}
rest.define.auth.bearer.token.file=the service use the oauth authentication token from the file {file}
rest.define.auth.bearer.code=the service use the oauth authentication authorization code {text}
rest.define.auth.bearer.code.file=the service use the oauth authentication authorization code from the file {file}
rest.define.auth.none=the service does not use authentication
rest.define.multipart.subtype={text} as subtype multipart
rest.define.attached.file=the attached file {name:text} is included with the file {file}
rest.define.attached.data=the attached file {name:text} is included with the following data:

rest.execute.GET.query=* (is|are) queried
rest.execute.GET.subject=* (is|are) requested
rest.execute.DELETE.subject=* (is|are) deleted
rest.execute.PUT.subject.from.document=* (is|are) modified with following data:
rest.execute.PUT.subject.from.file=* (is|are) modified with the data from the file {file}
rest.execute.PUT.subject.empty=* (is|are) modified
rest.execute.PATCH.subject.from.document=* (is|are) patched with the following data:
rest.execute.PATCH.subject.from.file=* (is|are) patched with the data from the file {file}
rest.execute.PATCH.subject.empty=* (is|are) patched
rest.execute.POST.subject.from.document=* (is|are) created with the following data:
rest.execute.POST.subject.from.file=* (is|are) created with the data from the file {file}
rest.execute.POST.subject.empty=* (is|are) created
rest.execute.POST.data.from.document=the following data is sent to the service:
rest.execute.POST.data.from.file=the data from the file {file} is sent to the service
rest.execute.POST.data.empty=the data info is sent to the service

rest.assert.response.HTTP.code=the response HTTP code {integer-assertion}
rest.assert.response.body.strict.from.document=the response is:
rest.assert.response.body.strict.from.file=the response is equal to the file {file}
rest.assert.response.body.strict.from.document.any-order=the response is \\(in any order\\):
rest.assert.response.body.strict.from.file.any-order=the response is equal to the file {file} \\(in any order\\)
rest.assert.response.body.loose.from.document=the response contains:
rest.assert.response.body.loose.from.file=the response contains the file {file}
rest.assert.response.body.contentType=the response content type is {word}
rest.assert.response.body.length=the response length {matcher:integer-assertion}
rest.assert.response.body.header.text=the text response header {name:word} {matcher:text-assertion}
rest.assert.response.body.header.integer=the integer response header {name:word} {matcher:integer-assertion}
rest.assert.response.body.header.decimal=the decimal response header {name:word} {matcher:decimal-assertion}
rest.assert.response.body.fragment.text=the text from response fragment {fragment:text} {matcher:text-assertion}
rest.assert.response.body.fragment.integer=the integer from response fragment {fragment:text} {matcher:integer-assertion}
rest.assert.response.body.fragment.decimal=the decimal from response fragment {fragment:text} {matcher:decimal-assertion}
rest.assert.response.body.schema.from.document=the response satisfies the following schema:
rest.assert.response.body.schema.from.file=the response satisfies the schema from the file {file}